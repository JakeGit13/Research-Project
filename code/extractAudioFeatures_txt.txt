function audioBlock = extractAudioFeatures(processedAudio, opts)
% EXTRACTAUDIOFEATURESTEST  F0-only extraction (one value per MR frame)
% Requires processedAudio from processAudioFile.m

    arguments
        processedAudio struct
        opts.VERBOSE (1,1) logical = false
        opts.Method  (1,:) char    = 'NCF'     % 'NCF' | 'ACF' | 'CEP' | 'SRH'
        opts.Range   (1,2) double   = [50 300] % Hz
        opts.UnvoicedValue (1,1) double = 0    % use 0 (or NaN) for unvoiced
    end

     fprintf("Running...\n");


    % --- pull from preprocessing struct ---

    frameSnippets      = processedAudio.frameSnippets;              % [winLen x nFrames]
    sampleRate     = processedAudio.sampleRate;
    winLen = processedAudio.windowLengthSamples;
    nFrames     = processedAudio.nFrames;



    %% EXTRACT F0 FROM EACH FRAME
    if opts.VERBOSE
        fprintf('[F0] sampleRate=%g Hz | winLen=%d samples (~%.1f ms) | frames=%d\n', ...
            sampleRate, winLen, 1000*winLen/sampleRate, nFrames);
    end

    % --- one F0 per frame ---
    f0   = zeros(nFrames,1);
    mask = false(nFrames,1);

    for k = 1:nFrames
        seg = frameSnippets(:,k);

        % One estimate per frame: window = full snippet; no overlap; no median smoothing
        f0k = pitch(seg, sampleRate, ...
            'Method', opts.Method, ...
            'Range',  opts.Range, ...
            'WindowLength', winLen, ...
            'OverlapLength', 0, ...
            'MedianFilterLength', 1);

        if ~isempty(f0k) && f0k(1) > 0
            f0(k)   = f0k(1);
            mask(k) = true;
        else
            f0(k)   = opts.UnvoicedValue;  % 0 (default) or NaN
            mask(k) = false;
        end
    end

    if opts.VERBOSE
        fprintf('[F0] voiced frames: %d/%d (%.1f%%)\n', sum(mask), nFrames, 100*sum(mask)/nFrames);
    end



    %% === Spectral PC1 (per frame) — energy-normalised + auto-select ==========
    % Build one log-mel vector per frame from the same 50 ms snippet
    melNumBands  = 40;
    melFreqRange = [50 8000];   % Hz
    if opts.VERBOSE
        fprintf('[SPC1] Building log-mel vectors: bands=%d, range=[%d %d] Hz\n', ...
            melNumBands, melFreqRange(1), melFreqRange(2));
    end
    
    melLog_raw = zeros(nFrames, melNumBands);   % T×B (pre-demean; used for energy proxy)
    melWin     = hann(winLen,'symmetric');
    fftLen     = 2^nextpow2(winLen);
    
    for k = 1:nFrames
        seg = frameSnippets(:,k) .* melWin;  % taper for a clean spectrum
        % melSpectrogram returns [bands × time]; here time≈1
        [melSpec, ~, ~] = melSpectrogram(seg, sampleRate, ...
            'Window',        melWin, ...
            'OverlapLength', 0, ...
            'FFTLength',     fftLen, ...
            'NumBands',      melNumBands, ...
            'FrequencyRange',melFreqRange, ...
            'SpectrumType',  'power');
        melLog_raw(k,:) = log(melSpec(:,1) + eps).';   % 1×B
    end
    
    % Proxy for per-frame energy (computed BEFORE de-meaning across bands)
    logEnergyPerFrame = log(sum(exp(melLog_raw), 2) + eps);  % T×1
    
    % Remove per-frame average across bands to down-weight pure loudness/tilt
    melLog_shape = melLog_raw - mean(melLog_raw, 2);         % T×B
    
    % Standardise per band across frames, then PCA
    useProvidedPCA = isfield(opts,'PCAmu') && ~isempty(opts.PCAmu) && ...
                     isfield(opts,'PCAsigma') && ~isempty(opts.PCAsigma) && ...
                     isfield(opts,'PC1') && ~isempty(opts.PC1);
    
    if useProvidedPCA
        if opts.VERBOSE
            fprintf('[SPC1] Using provided PCA params (mu/std/PC1). NOTE: these must be trained on the SAME de-meaned mel (melLog_shape).\n');
        end
        mu    = opts.PCAmu(:).';     % 1×B
        sigma = opts.PCAsigma(:).';  % 1×B
        sigma(sigma==0) = eps;
        melZ  = (melLog_shape - mu) ./ sigma;     % T×B
        spectralPC1 = melZ * opts.PC1(:);         % T×1
    else
        if opts.VERBOSE
            fprintf('[SPC1] NO PCA params provided; fitting PCs on this utterance (temporary).\n');
        end
        mu    = mean(melLog_shape, 1);
        sigma = std(melLog_shape, 0, 1); sigma(sigma==0) = eps;
        melZ  = (melLog_shape - mu) ./ sigma;     % T×B
    
        % Get first TWO PCs and avoid an energy-like component
        [coeff, score, explained] = pca(melZ, 'NumComponents', 2); %#ok<PFBNS>
        pc1 = score(:,1);  pc2 = score(:,2);
    
        r1 = corr(pc1, logEnergyPerFrame, 'rows','complete');
        r2 = corr(pc2, logEnergyPerFrame, 'rows','complete');
    
        usePC2 = (r1 > 0.90) && (abs(r2) < abs(r1));   % switch if PC1≈energy
        spectralPC1 = usePC2 * pc2 + (~usePC2) * pc1;
    
        if opts.VERBOSE
            fprintf('[SPC1] Temp PCs explain: PC1=%.1f%%, PC2=%.1f%%\n', explained(1), explained(2));
            fprintf('[SPC1] corr(PC1, energy)=%.3f | corr(PC2, energy)=%.3f | selected=%s\n', ...
                    r1, r2, ternary(usePC2,'PC2','PC1'));
        end
    end
    
    % Diagnostics
    fprintf('[SPC1] mel matrix (raw):   %d frames × %d bands\n', size(melLog_raw,1), size(melLog_raw,2));
    fprintf('[SPC1] corr(selected, log-mel energy) = %.3f\n', ...
            corr(spectralPC1, logEnergyPerFrame, 'rows','complete'));


   %% === MFCC c1 (per frame) — corrected minimal =====================
    mfccNumCoeffs = 13;                          % we keep only c1
    mfccWin       = hann(winLen,'symmetric');    % same 50 ms window
    mfcc_c1       = zeros(nFrames,1);
    
    if opts.VERBOSE
        fprintf('[MFCC] Extracting c1 per frame: NumCoeffs=%d, Window=%.1f ms (default mel bank)\n', ...
            mfccNumCoeffs, 1000*winLen/sampleRate);
    end
    
    for k = 1:nFrames
        seg = frameSnippets(:,k);
        coeffs_k = mfcc(seg, sampleRate, ...
            'Window',        mfccWin, ...
            'OverlapLength', 0, ...
            'NumCoeffs',     mfccNumCoeffs, ...
            'LogEnergy',     'Ignore');   % no BandEdges here
        mfcc_c1(k) = coeffs_k(1);         % keep first non-zero cepstral coeff
    end
    
    if opts.VERBOSE
        pct = prctile(mfcc_c1,[5 25 50 75 95]);
        fprintf('[MFCC] c1 stats: min=%.3f, mean=%.3f, median=%.3f, max=%.3f\n', ...
            min(mfcc_c1), mean(mfcc_c1), median(mfcc_c1), max(mfcc_c1));
        fprintf('[MFCC] c1 percentiles: p5=%.3f, p25=%.3f, p50=%.3f, p75=%.3f, p95=%.3f\n', pct);
        
    end
    
    %% PROBS DON'T NEED THIS 
    audioFeatures.mfcc_c1        = mfcc_c1(:);
    audioFeatures.mfcc_numCoeffs = mfccNumCoeffs;

    audioFeatures.spectralPC1     = spectralPC1(:);   % nFrames×1
    audioFeatures.melNumBands     = melNumBands;
    audioFeatures.melFreqRangeHz  = melFreqRange;
    audioFeatures.f0Hz                = f0;                          % nFrames×1
    audioFeatures.voicedMask          = mask;                        % nFrames×1 (logical)
    audioFeatures.centerTimeSec       = processedAudio.centerTimeSec;
    audioFeatures.sampleRate          = sampleRate;
    audioFeatures.windowLengthSamples = winLen;
    audioFeatures.nFrames             = nFrames;


    audioBlock = [f0(:).', ...
          mfcc_c1(:).' ];
    audioBlock = reshape(audioBlock, 2, []);          % 2×T
    audioBlock(isnan(audioBlock)) = 0;
    
    % z-score per row across time (fusion-stage)
    mu    = mean(audioBlock,2);
    sigma = std(audioBlock,0,2); sigma(sigma==0)=1;
    A_z   = (audioBlock - mu)./sigma;
    

    
        fprintf("Extract audio features: DONE\n");
    end


function out = ternary(c,a,b), if c, out=a; else, out=b; end
end












