function trimodalH2

clc;

dataDir = '/Users/jaker/Research-Project/data';
dataFile = 'mrAndVideoData.mat';
audioFile = 'audioFeaturesData.mat';


usePar = true; % remove this as no option for series processing, not sure if that's a bad thing
VERBOSE = true;


% === H2: choose the hidden visual target ===
reconstructId = 2; % H2 target: 1 = MR, 2 = Video   (must be 1 or 2)
shuffleTarget  = 3; % H2 null: shuffle Audio only (Tri-ShufA)

if ~(reconstructId==1 || reconstructId==2)
    error('H2: reconstructId must be 1 (MR) or 2 (Video).');
end
if shuffleTarget ~= 3
    error('H2: shuffleTarget must be 3 (Audio) for Tri-ShufA.');
end
blockNames = {'MR','Video','Audio'}; % used in prints




nBoots = 500; % # bootstraps
% ******************************************************************************************************************************************************


% Reset random seed
rng('default');

addpath(dataDir) % Add the user-defined data directory to the path 
load(dataFile,'data');          % MR + video
load(audioFile,'audioData');   % Audio


actors = [data.actor]; % Array of actor numbers
sentences = [data.sentence]; % Array of sentence numbers

%% PCA on hybrid facial video and vocal-tract MR images

for ii = 9%:length(actors)
    
    clear results;
    
    %% === Load/Assemble Blocks ===
    thisMRWarp  = data(ii).mr_warp2D;                         % (p_mr x T)
    thisVidWarp = data(ii).vid_warp2D;                        % (p_vid x T)
    thisAudio   = audioData(ii).audioFeatures';  % (p_aud x T)
    
    T = size(thisMRWarp, 2);    % Amount of frames

    if VERBOSE
        fprintf('Item %d\n', ii);
        fprintf('MR:    %d features x %d frames\n', size(thisMRWarp,1), T);
        fprintf('Video: %d features x %d frames\n', size(thisVidWarp,1), T);
        fprintf('Audio: %d features x %d frames\n\n', size(thisAudio,1),   T);
    end



    %% === Trimodal block balancing (MFA-style) ===============================
    % Diagnostics BEFORE weighting
    [lam1_mr,  fro_mr]   = block_scale_stats(thisMRWarp);
    [lam1_vid, fro_vid]  = block_scale_stats(thisVidWarp);
    [lam1_aud, fro_aud]  = block_scale_stats(thisAudio);
    fprintf('Before weighting:  PC1 λ  MR=%.4g | Video=%.4g | Audio=%.4g   | Fro MR=%.3g | Fro Video=%.3g | Fro Audio=%.3g\n', ...
            lam1_mr, lam1_vid, lam1_aud, fro_mr, fro_vid, fro_aud);

    % Weights to equalise each block's dominant variance scale
    w_mr  = 1/sqrt(lam1_mr);
    w_vid = 1/sqrt(lam1_vid);
    w_aud = 1/sqrt(lam1_aud);

    % Apply weights
    thisMRWarpW   =  w_mr * thisMRWarp;
    thisVidWarpW  =  w_vid * thisVidWarp;
    thisAudioW    =  w_aud * thisAudio;

    % Diagnostics AFTER weighting
    [lam1_mr_a,  fro_mr_a]   = block_scale_stats(thisMRWarpW);
    [lam1_vid_a, fro_vid_a]  = block_scale_stats(thisVidWarpW);
    [lam1_aud_a, fro_aud_a]  = block_scale_stats(thisAudioW);
    fprintf('After  weighting:  PC1 λ  MR=%.4g | Video=%.4g | Audio=%.4g   | Fro MR=%.3g | Fro Video=%.3g | Fro Audio=%.3g\n\n', ...
            lam1_mr_a, lam1_vid_a, lam1_aud_a, fro_mr_a, fro_vid_a, fro_aud_a);

    % Use weighted blocks for PCA and reconstruction
    mixWarps = [thisMRWarpW; thisVidWarpW; thisAudioW];



%% ============================================================================

    
    % Perform a PCA on the hybrid data
    [origPCA,origMorphMean,origloadings] = doPCA(mixWarps);
    
    % Do the non-shuffled reconstruction for the original order **********************************************************************
    
    % Indexes of boundaries between MR and video
    bMR  = size(thisMRWarpW, 1);
    bVID = size(thisVidWarpW, 1);
    bAUD = size(thisAudioW,  1);

    elementBoundaries = [0, bMR, bMR + bVID, bMR + bVID + bAUD];
    nFrames = T;  % already defined above


    if VERBOSE
        fprintf('Hidden/target block: %s | Shuffle target: %s\n', ...
            blockNames{reconstructId}, blockNames{shuffleTarget});
    end

    % Centre first by the PCA-fit mean, then mask, then project
    partialMorphMean = origMorphMean;
    partial_centered = bsxfun(@minus, mixWarps, partialMorphMean);
    
    % Zero the hidden target block (MR if 1, Video if 2)
    t1 = elementBoundaries(reconstructId)+1;
    t2 = elementBoundaries(reconstructId+1);
    partial_centered(t1:t2, :) = 0;
    
    % Sanity: hidden rows must be zero
    assert(norm(partial_centered(t1:t2,:),'fro')==0, 'Hidden target rows not zero after masking.');
    
    partial_loading = partial_centered'*origPCA;



    %% === H2 Tri-real: loadings-space only (paper-faithful) =================
    % We keep the unshuffled original vs reconstructed loadings for Tri.
    % (Stats are computed later in the common "Statistics" section.)
    if VERBOSE
        obsIdx = setdiff([1 2 3], reconstructId, 'stable'); % observed blocks in order
        fprintf('H2 Tri-real: target=%s | observed = %s + %s\n', ...
            blockNames{reconstructId}, blockNames{obsIdx(1)}, blockNames{obsIdx(2)});
    end



    % (H2) No evaluation-only audio null here; H2 uses refit-permutation on Audio (Tri-ShufA).







    
    % Store the loadings for further processing
    results.nonShuffledLoadings = origloadings;
    results.nonShuffledReconLoadings = partial_loading;


    %% === H2 Bi baseline: fit on MR+Video only, same MR/Video weights =======
    % Reuse w_mr and w_vid from Tri to keep MR/Video scaling comparable.
    mixWarpsBi = [ (w_mr  * thisMRWarp); (w_vid * thisVidWarp) ];
    
    % PCA on Bi
    [origPCA_bi, origMorphMean_bi, origloadings_bi] = doPCA(mixWarpsBi);
    
    % Boundaries for Bi (no Audio rows here)
    bMR  = size(w_mr  * thisMRWarp, 1);
    bVID = size(w_vid * thisVidWarp, 1);
    elementBoundariesBi = [0, bMR, bMR + bVID];
    
    % Zero the target block within Bi
    % Centre first in Bi space, then mask, then project
    partialMorphMean_bi = origMorphMean_bi;
    partial_centered_bi = bsxfun(@minus, mixWarpsBi, partialMorphMean_bi);
    
    tb1 = elementBoundariesBi(reconstructId)+1;
    tb2 = elementBoundariesBi(reconstructId+1);
    partial_centered_bi(tb1:tb2, :) = 0;
    
    assert(norm(partial_centered_bi(tb1:tb2,:),'fro')==0, 'Hidden target rows not zero in Bi after masking.');
    
    partial_loading_bi = partial_centered_bi' * origPCA_bi;
    
    % Compute Bi stats now (R, slope, SSE) so we can print them later
    loadings1D_bi      = origloadings_bi(:);
    reconLoadings1D_bi = partial_loading_bi(:);
    SSE_bi  = sum((loadings1D_bi - reconLoadings1D_bi).^2);
    [R_bi,~] = corr(loadings1D_bi, reconLoadings1D_bi);
    p_bi    = polyfit(loadings1D_bi, reconLoadings1D_bi, 1);
    slope_bi = p_bi(1);
    
    if VERBOSE
        fprintf('H2 Bi baseline: target=%s | R=%.4f, slope=%.4f, SSE=%.3e\n', ...
            blockNames{reconstructId}, R_bi, slope_bi, SSE_bi);
    end
    
        
    % Display ************************************************************************************************************************
    
    figure;
    
    % Original and reconstructed loadings
    plot(results.nonShuffledLoadings,results.nonShuffledReconLoadings,'.');
    
    % Unity line
    hline=refline(1,0);
    hline.Color = 'k';
    
    xlabel('Original loadings');ylabel('Reconstructed loadings');

    % Do the shuffled reconstruction *************************************************************************************************
    
    % Create indexes for nBoot random permutations using a loop
    permIndexes = NaN(nBoots,nFrames);
    for bootI = 1:nBoots
        permIndexes(bootI,:) = randperm(nFrames);
    end
    
    % (H2) No audio feature-space metric per shuffle needed.




    allShuffledOrigLoad  = cell(nBoots,1);
    allShuffledReconLoad = cell(nBoots,1);

    
    % Do PCA on one shuffled combo
    nCores = feature('numcores');
    tic
    if usePar && nCores>2
        disp('Using parallel processing...');
        
        poolOpen = gcp('nocreate');
        if isempty(poolOpen)
            pp = parpool(nCores-1); % Leave one core free
        end
        
        parfor bootI = 1:nBoots
            
            %% SHUFFLE WARPS  --- Build shuffled dataset: permute only the selected block ---

            switch shuffleTarget
                case 1  % shuffle MR frames
                    shMR  = thisMRWarpW(:, permIndexes(bootI,:));
                    shVID = thisVidWarpW;
                    shAUD = thisAudioW;
                case 2  % shuffle Video frames
                    shMR  = thisMRWarpW;
                    shVID = thisVidWarpW(:, permIndexes(bootI,:));
                    shAUD = thisAudioW;
                case 3  % shuffle Audio frames
                    shMR  = thisMRWarpW;
                    shVID = thisVidWarpW;
                    shAUD = thisAudioW(:, permIndexes(bootI,:));
                otherwise
                    error('shuffleTarget must be 1 (MR), 2 (Video), or 3 (Audio).');
            end
            shuffWarps = [shMR; shVID; shAUD];

            if VERBOSE && bootI==1
                fprintf('Shuffle check: permuting %s frames only.\n', blockNames{shuffleTarget});
            end


            [PCA,MorphMean,loadings] = doPCA(shuffWarps);
            
            partial_data = shuffWarps;
            partial_data(elementBoundaries(reconstructId)+1:elementBoundaries(reconstructId+1),:) = 0; % zero the target block
            partialMorphMean = MorphMean;
            partial_centered = bsxfun(@minus, partial_data, partialMorphMean); % resizes partialMorphMean to make subtraction possible (could use matrix maths?)
            partial_loading = partial_centered'*PCA;


            % (H2) No audio feature-space metric here; loadings-space stats are computed after the loop.


            
            allShuffledOrigLoad{bootI} = loadings;
            allShuffledReconLoad{bootI} = partial_loading;
        end
    else
        disp('NOT using parallel processing...');
    end
    
    results.allShuffledOrigLoad = allShuffledOrigLoad;
    results.allShuffledReconLoad = allShuffledReconLoad;
    toc 
    
    %% Statistics ************************************************************************************************************************
    
    % (H2) No audio feature-space summary; proceed to loadings-space stats for H2.





    % Unshuffled
    loadings1D = results.nonShuffledLoadings(:);
    reconLoadings1D = results.nonShuffledReconLoadings(:);
    
    SSE = sum((loadings1D-reconLoadings1D).^2); % sum of squared error
    [R,~] = corr(loadings1D,reconLoadings1D); % Pearson correlation
    p = polyfit(loadings1D,reconLoadings1D,1); % linear fit
    
    unshuffstats = [R p(1) SSE];
    
    % Shuffled
    shuffstats = NaN(3,nBoots);
    for bootI=1:nBoots
        loadings1D = results.allShuffledOrigLoad{bootI}(:);
        reconLoadings1D = results.allShuffledReconLoad{bootI}(:);
        
        SSE = sum((loadings1D-reconLoadings1D).^2); % sum of squared error
        [R,~] = corr(loadings1D,reconLoadings1D); % Pearson correlation
        p = polyfit(loadings1D,reconLoadings1D,1); % linear fit
        
        shuffstats(:,bootI) = [R p(1) SSE];
    end


    % After computing unshuffstats (R, slope, SSE) and shuffstats:
    p_R    = mean(shuffstats(1,:) >= unshuffstats(1));
    p_slope= mean(shuffstats(2,:) >= unshuffstats(2));
    p_SSE  = mean(shuffstats(3,:) <= unshuffstats(3)); % SSE lower is better
    
    if VERBOSE
        fprintf('H2 Tri-real (target=%s): R=%.4f, slope=%.4f, SSE=%.3e | vs Tri-ShufA p: [R=%.3g, slope=%.3g, SSE=%.3g]\n', ...
            blockNames{reconstructId}, unshuffstats(1), unshuffstats(2), unshuffstats(3), p_R, p_slope, p_SSE);
    
        fprintf('H2 Bi baseline (target=%s): R=%.4f, slope=%.4f, SSE=%.3e | ΔR=%.4f, ΔSSE=%.3e (Tri−Bi)\n', ...
            blockNames{reconstructId}, R_bi, slope_bi, SSE_bi, unshuffstats(1) - R_bi, unshuffstats(3) - SSE_bi);
    end


    
    % Display ************************************************************************************************************************
    
    figure;
    
    % Original and reconstructed loadings
    subplot(2,3,2);
    plot(results.nonShuffledLoadings,results.nonShuffledReconLoadings,'.');
    
    % Unity line
    hline=refline(1,0);
    hline.Color = 'k';
    
    xlabel('Original loadings');ylabel('Reconstructed loadings');
    
    statStrings = {'Correlation coefficient','Linear Fit Gradient','SSE'};
    
    for statI = 1:3
        
        % Shuffled distributions
        subplot(2,3,statI+3);
        
        histogram(shuffstats(statI,:),50);hold on
        axis tight
        plot(unshuffstats([statI statI]),ylim,'r--','linewidth',2);
        
        xlabel(statStrings{statI});ylabel('Frequency');
        
    end
end
end % end pcaAndShufflingExample

%% doPCA
function [prinComp,MorphMean,loadings] = doPCA(data)

% Mean each row (across frames)
MorphMean = mean(data, 2);

% Subtract overall mean from each frame
data = bsxfun(@minus, data, MorphMean);
xxt        = data'*data;
[~,LSq,V]  = svd(xxt);
LInv       = 1./sqrt(diag(LSq));
prinComp  = data * V * diag(LInv);
loadings = (data')*prinComp;
end % end doPCA


function [lam1, fro] = block_scale_stats(X)
% Row-centre within block (match the main script’s convention)
Xc  = bsxfun(@minus, X, mean(X,2));
% Leading eigenvalue of Xc'Xc equals the square of the top singular value
% Using economy SVD is fine here given T << p in your data layout
[~, S, ~] = svd(Xc' * Xc, 'econ');
lam1 = S(1,1);
fro  = norm(Xc, 'fro');
end